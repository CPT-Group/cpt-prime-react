import { OAuth2Client } from "google-auth-library";
import { google, youtube_v3 } from "googleapis";

/**
 * YouTube Data API v3 Service (Official API)
 *
 * Provides access to YouTube captions via the official Google API.
 *
 * LIMITATIONS (from youtube-api-expert):
 * - captions.download requires OAuth 2.0 (not just API key)
 * - Cannot access auto-generated captions (trackKind=asr)
 * - Costs 200 quota units per download (50/day max on free tier)
 * - Most YouTube videos ONLY have auto-generated captions
 *
 * This is why scraping fallback is necessary!
 */
export class YouTubeAPIService {
  private youtube: youtube_v3.Youtube | null = null;
  private apiKey: string | null = null;
  private oauth2Client: OAuth2Client | null = null;

  constructor() {
    this.initialize();
  }

  private initialize() {
    // Try to load API key from environment
    this.apiKey = process.env.YOUTUBE_API_KEY || null;

    if (this.apiKey) {
      // Initialize with API key (sufficient for captions.list)
      this.youtube = google.youtube({
        version: "v3",
        auth: this.apiKey,
      });
      console.log("✓ YouTube Data API v3 initialized with API key");
    } else {
      console.warn(
        "⚠️  YOUTUBE_API_KEY not configured. YouTube API features disabled."
      );
      console.warn("   Set YOUTUBE_API_KEY environment variable to enable.");
    }

    // Try to initialize OAuth2 client (for captions.download)
    const clientId = process.env.YOUTUBE_CLIENT_ID;
    const clientSecret = process.env.YOUTUBE_CLIENT_SECRET;
    const refreshToken = process.env.YOUTUBE_REFRESH_TOKEN;

    if (clientId && clientSecret) {
      this.oauth2Client = new google.auth.OAuth2(
        clientId,
        clientSecret,
        "urn:ietf:wg:oauth:2.0:oob" // For non-web applications
      );

      if (refreshToken) {
        this.oauth2Client.setCredentials({
          refresh_token: refreshToken,
        });
        console.log(
          "✓ YouTube OAuth2 configured (captions.download available)"
        );
      } else {
        console.warn(
          "⚠️  YOUTUBE_REFRESH_TOKEN not configured. captions.download unavailable."
        );
      }
    }
  }

  /**
   * Check if service is available (has API key)
   */
  isAvailable(): boolean {
    return this.youtube !== null;
  }

  /**
   * Check if OAuth2 is configured (for captions.download)
   */
  hasOAuth(): boolean {
    return (
      this.oauth2Client !== null &&
      this.oauth2Client.credentials.refresh_token !== undefined
    );
  }

  /**
   * List available captions for a video
   *
   * Quota Cost: 50 units
   * Authentication: API key (sufficient)
   *
   * Returns metadata about caption tracks including:
   * - id: Caption track ID (needed for download)
   * - language: Language code (en, es, fr, etc.)
   * - name: Display name
   * - trackKind: 'asr' (auto-generated) or 'standard' (manual)
   * - status: 'serving' or 'failed'
   */
  async listCaptions(videoId: string): Promise<{
    captions: Array<{
      id: string;
      language: string;
      name: string;
      trackKind: "asr" | "standard" | "forced";
      status: string;
      isAutoGenerated: boolean;
    }>;
    metadata: {
      videoId: string;
      totalCaptions: number;
      manualCaptions: number;
      autoGeneratedCaptions: number;
    };
  }> {
    if (!this.youtube) {
      throw new Error(
        "YouTube API not initialized. Set YOUTUBE_API_KEY environment variable."
      );
    }

    try {
      const response = await this.youtube.captions.list({
        part: ["snippet"],
        videoId: videoId,
      });

      const captions = (response.data.items || []).map((item) => ({
        id: item.id || "",
        language: item.snippet?.language || "",
        name: item.snippet?.name || "",
        trackKind:
          (item.snippet?.trackKind as "asr" | "standard" | "forced") ||
          "standard",
        status: item.snippet?.status || "",
        isAutoGenerated: item.snippet?.trackKind === "asr",
      }));

      const manualCaptions = captions.filter((c) => c.trackKind === "standard");
      const autoGeneratedCaptions = captions.filter(
        (c) => c.trackKind === "asr"
      );

      return {
        captions,
        metadata: {
          videoId,
          totalCaptions: captions.length,
          manualCaptions: manualCaptions.length,
          autoGeneratedCaptions: autoGeneratedCaptions.length,
        },
      };
    } catch (error: any) {
      throw this.handleAPIError(error, "listCaptions");
    }
  }

  /**
   * Download caption content (REQUIRES OAuth 2.0)
   *
   * Quota Cost: 200 units
   * Authentication: OAuth 2.0 (API key NOT sufficient)
   *
   * CRITICAL LIMITATION: Does NOT work for auto-generated captions (trackKind=asr)
   * Will return 403 Forbidden if attempting to download auto-generated captions.
   *
   * Most YouTube videos ONLY have auto-generated captions, making this method
   * rarely usable in practice. This is why scraping fallback is necessary.
   */
  async downloadCaption(
    captionId: string,
    format: "srt" | "vtt" | "ttml" | "sbv" = "srt"
  ): Promise<{
    content: string;
    format: string;
    captionId: string;
  }> {
    if (!this.oauth2Client || !this.oauth2Client.credentials.refresh_token) {
      throw new Error(
        "OAuth 2.0 not configured. captions.download requires OAuth. " +
          "Set YOUTUBE_CLIENT_ID, YOUTUBE_CLIENT_SECRET, and YOUTUBE_REFRESH_TOKEN."
      );
    }

    try {
      // Create YouTube client with OAuth
      const youtubeWithAuth = google.youtube({
        version: "v3",
        auth: this.oauth2Client,
      });

      // Download caption
      const response = await youtubeWithAuth.captions.download(
        {
          id: captionId,
          tfmt: format,
        },
        {
          responseType: "text",
        }
      );

      return {
        content: response.data as string,
        format,
        captionId,
      };
    } catch (error: any) {
      // Handle auto-generated caption error specifically
      if (error.code === 403) {
        throw new Error(
          "Cannot download this caption. " +
            "YouTube API does not support downloading auto-generated captions (trackKind=asr). " +
            "Use scraping fallback for auto-generated captions."
        );
      }
      throw this.handleAPIError(error, "downloadCaption");
    }
  }

  /**
   * Get video information (for validation)
   */
  async getVideoInfo(videoId: string): Promise<{
    id: string;
    title: string;
    channelTitle: string;
    publishedAt: string;
    duration: string;
  } | null> {
    if (!this.youtube) {
      throw new Error("YouTube API not initialized.");
    }

    try {
      const response = await this.youtube.videos.list({
        part: ["snippet", "contentDetails"],
        id: [videoId],
      });

      if (!response.data.items || response.data.items.length === 0) {
        return null; // Video not found
      }

      const video = response.data.items[0];
      return {
        id: video.id || videoId,
        title: video.snippet?.title || "",
        channelTitle: video.snippet?.channelTitle || "",
        publishedAt: video.snippet?.publishedAt || "",
        duration: video.contentDetails?.duration || "",
      };
    } catch (error: any) {
      throw this.handleAPIError(error, "getVideoInfo");
    }
  }

  /**
   * Parse transcript content into structured segments
   */
  parseTranscript(
    content: string,
    format: string
  ): Array<{
    text: string;
    start: number;
    duration: number;
  }> {
    // Simple SRT parser (most common format)
    if (format === "srt") {
      return this.parseSRT(content);
    }

    // For other formats, return raw content as single segment
    return [
      {
        text: content,
        start: 0,
        duration: 0,
      },
    ];
  }

  /**
   * Simple SRT parser
   */
  private parseSRT(
    content: string
  ): Array<{ text: string; start: number; duration: number }> {
    const segments: Array<{ text: string; start: number; duration: number }> =
      [];
    const blocks = content.split("\n\n");

    for (const block of blocks) {
      const lines = block.trim().split("\n");
      if (lines.length < 3) continue;

      // Line 0: sequence number (ignore)
      // Line 1: timestamps
      // Line 2+: text
      const timeMatch = lines[1].match(
        /(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/
      );

      if (timeMatch) {
        const startSeconds =
          parseInt(timeMatch[1]) * 3600 +
          parseInt(timeMatch[2]) * 60 +
          parseInt(timeMatch[3]) +
          parseInt(timeMatch[4]) / 1000;

        const endSeconds =
          parseInt(timeMatch[5]) * 3600 +
          parseInt(timeMatch[6]) * 60 +
          parseInt(timeMatch[7]) +
          parseInt(timeMatch[8]) / 1000;

        const text = lines.slice(2).join(" ");

        segments.push({
          text,
          start: startSeconds,
          duration: endSeconds - startSeconds,
        });
      }
    }

    return segments;
  }

  /**
   * Handle API errors with user-friendly messages
   */
  private handleAPIError(error: any, method: string): Error {
    const statusCode = error.code || error.response?.status;
    const errorMessage = error.message || "Unknown error";

    switch (statusCode) {
      case 400:
        return new Error(
          `Bad request to ${method}: ${errorMessage}. Check video ID format.`
        );

      case 401:
        return new Error(
          `Authentication failed for ${method}: Invalid or expired API key/OAuth token.`
        );

      case 403:
        if (errorMessage.includes("quota")) {
          return new Error(
            `YouTube API quota exceeded. Daily limit: 10,000 units. ` +
              `${method} costs: captions.list=50, captions.download=200. ` +
              `Quota resets at midnight Pacific Time. Consider using scraping fallback.`
          );
        }
        return new Error(`Access forbidden for ${method}: ${errorMessage}`);

      case 404:
        return new Error(
          `Resource not found for ${method}: Video or caption does not exist.`
        );

      case 429:
        return new Error(
          `Rate limit exceeded for ${method}. Retry with exponential backoff.`
        );

      default:
        return new Error(
          `YouTube API error in ${method} (${statusCode}): ${errorMessage}`
        );
    }
  }

  /**
   * Get current quota usage estimate (approximate)
   */
  getQuotaUsageEstimate(): {
    message: string;
    recommendations: string[];
  } {
    return {
      message:
        "Default quota: 10,000 units/day. " +
        "captions.list: 50 units. captions.download: 200 units. " +
        "Max ~50 caption downloads per day on free tier.",
      recommendations: [
        "Cache transcripts (they rarely change)",
        "Use scraping fallback to conserve quota",
        "Request quota increase for production use",
        "Monitor usage in Google Cloud Console",
        "Prefer captions.list (cheaper) to check availability first",
      ],
    };
  }
}
